using Godot;
using System.Collections.Generic;

public partial class Pathfinding : Node
{
    Vector2 gridSize;
    GDScript Graphics = (GDScript)GD.Load("res://scripts/graphics/Graphics.gd");

    public void Setup(Vector2 gridSize) {
        this.gridSize = gridSize;
    }

    public Vector2[] FindPath(Vector2 start, Vector2 end)
    {
        PathNode startNode = new(start, gridSize);
        startNode.hScore = H(start, end);
        startNode.gScore = 0;
        startNode.CalculateFCost();
        startNode.cameFrom = null;

        PriorityQueue<PathNode, float> openSet = new();

        openSet.Enqueue(startNode, startNode.fScore);

        PathNode current;
        while (openSet.Count > 0) {
            current = openSet.Dequeue();

            if (current.position == end) {
                // success
                return ReconstructPath(current).ToArray();
            }

            foreach (PathNode neighbor in current.GetNeighbors()) {
                int scale = (int)Graphics.Get("SCALE");
                GD.Print(scale);
                float tentative_gScore = current.gScore + H(current.position, neighbor.position);

                if (tentative_gScore < neighbor.gScore) {
                    neighbor.cameFrom = current;
                    neighbor.gScore = tentative_gScore;
                    neighbor.CalculateFCost();

                    if (!OpenSetHasNode(openSet, neighbor)) {
                        openSet.Enqueue(neighbor, neighbor.fScore);
                    }
                }
            }

        }

        return null;
    }

    List<Vector2> ReconstructPath(PathNode node) {
        List<Vector2> list = new();

        while (node.cameFrom != null) {
            list.Add(node.position);
            node = node.cameFrom;
        }

        list.Reverse();
        return list;
    }

    bool OpenSetHasNode(PriorityQueue<PathNode, float> openSet, PathNode node) {

        foreach ((PathNode setNode, float priority) in openSet.UnorderedItems) {
            if (setNode.position == node.position) {
                return true;
            }
        }

        return false;
    }

    float H(Vector2 start, Vector2 end)
    {
        return Mathf.Sqrt(Mathf.Abs(Mathf.Pow(end.X - start.X, 2)) + Mathf.Abs(Mathf.Pow(end.Y - start.Y, 2)));
    }

}
